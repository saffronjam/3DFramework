#pragma once

#include "Saffron/Core/UUID.h"
#include "Saffron/Core/TypeDefs.h"

namespace Se
{
class BasicSignal
{
public:
	using TypeID = UUID;

public:
	BasicSignal() = default;
	virtual	~BasicSignal() = default;

	/** Generate a UUID for a signal.
	 * @return Signal UUID.
	 */
	static TypeID GenerateTypeID();
};

template<typename t_ParamType>
class Signal : public BasicSignal
{
public:
	Signal() = default;
	Signal(const Signal &) = delete;
	Signal &operator=(const Signal &) = delete;

	Signal(Signal &&other) noexcept
		: m_Delegates(std::move(other.m_Delegates))
	{
	}
	Signal &operator=(Signal &&other) noexcept
	{
		m_Delegates = std::move(other.m_Delegates);
		return *this;
	}

	/** Connect to free function.
	 * @param delegate Free function.
	 * @return Connection serial, use for disconnecting.
	 */
	unsigned int Connect(Function<void(t_ParamType)> delegate)
	{
		if ( !m_Delegates )
		{
			m_Delegates.reset(new DelegateMap);
		}

		(*m_Delegates)[m_Serial] = delegate;
		return m_Serial++;
	}

	/** Disconnect signal.
	 * @param serial Serial generated by Connect().
	 */
	void Disconnect(unsigned int serial)
	{
		if ( !m_Delegates )
		{
			return;
		}

		m_Delegates->erase(serial);

		if ( m_Delegates->empty() )
		{
			m_Delegates.reset();
		}
	}

	/** Emit.
	 */
	void operator()(t_ParamType param) const
	{
		if ( !m_Delegates )
		{
			return;
		}

		for ( const auto &delegate : *m_Delegates )
		{
			delegate.second(param);
		}
	}


private:
	typedef Map<unsigned int, Function<void(t_ParamType)>> DelegateMap;
	std::unique_ptr<DelegateMap> m_Delegates;
	static Uint32 m_Serial;
};

template<>
class Signal<void> : public BasicSignal
{
public:
	Signal() = default;
	Signal(const Signal &) = delete;
	Signal &operator=(const Signal &) = delete;

	Signal(Signal &&other) noexcept
		: m_Delegates(std::move(other.m_Delegates))
	{
	}
	Signal &operator=(Signal &&other) noexcept
	{
		m_Delegates = std::move(other.m_Delegates);
		return *this;
	}

	/** Connect to free function.
	 * @param delegate Free function.
	 * @return Connection serial, use for disconnecting.
	 */
	unsigned int Connect(Function<void()> delegate)
	{
		if ( !m_Delegates )
		{
			m_Delegates.reset(new DelegateMap);
		}

		(*m_Delegates)[m_Serial] = delegate;
		return m_Serial++;
	}

	/** Disconnect signal.
	 * @param serial Serial generated by Connect().
	 */
	void Disconnect(unsigned int serial)
	{
		if ( !m_Delegates )
		{
			return;
		}

		m_Delegates->erase(serial);

		if ( m_Delegates->empty() )
		{
			m_Delegates.reset();
		}
	}

	void operator()() const
	{
		if ( !m_Delegates )
		{
			return;
		}

		for ( const auto &delegate : *m_Delegates )
		{
			delegate.second();
		}
	}


private:
	typedef Map<unsigned int, Function<void()>> DelegateMap;
	std::unique_ptr<DelegateMap> m_Delegates;
	static Uint32 m_Serial;
};

template<typename t_ParamType>
Uint32 Signal<t_ParamType>::m_Serial = 0;


template <typename t_ParamType>
struct SignalAggregate
{
	using ParamType = t_ParamType;
	BasicSignal::TypeID TypeID;

	SignalAggregate() : TypeID(0ull) {}
};


/** SignalContainer
* Should only be used internally to store signals.
* Needed to reduce memory consumption
*/
class SignalContainer
{
public:
	/** Access signal.
	 * @param signalAggregate
	 * @return Reference to the requested signal.
	 */
	template<typename t_ParamType>
	BasicSignal &operator[](SignalAggregate<t_ParamType> &signalAggregate)
	{
		if ( !m_Signals )
		{
			m_Signals.reset(new SignalMap);
		}

		auto signalIter = m_Signals->find(signalAggregate.TypeID);

		if ( signalIter == m_Signals->end() )
		{
			signalAggregate.TypeID = BasicSignal::GenerateTypeID();
			signalIter = m_Signals->emplace(signalAggregate.TypeID, new Signal<t_ParamType>()).first;
		}

		return *signalIter->second;
	}

	/** Emit signal.
	 * @param signalAggregate
	 * @param param
	 */
	template<typename t_ParamType, typename... Param>
	void Emit(const SignalAggregate<t_ParamType> &signalAggregate, Param &&... param)
	{

		if ( !m_Signals || !signalAggregate.TypeID )
		{
			return;
		}

		const auto signalIter = m_Signals->find(signalAggregate.TypeID);

		if ( signalIter != m_Signals->end() )
		{
			auto *dyncastSignal = dynamic_cast<Signal<t_ParamType> *>(signalIter->second);
			SE_CORE_ASSERT(dyncastSignal);
			(*dyncastSignal)(std::forward<Param>(param)...);
		}
	}

	/** Emit signal.
	 * @param signalAggregate
	 */
	template<>
	void Emit(const SignalAggregate<void> &signalAggregate)
	{
		if ( !m_Signals || !signalAggregate.TypeID )
		{
			return;
		}

		const auto signalIter = m_Signals->find(signalAggregate.TypeID);

		if ( signalIter != m_Signals->end() )
		{
			auto *dyncastSignal = dynamic_cast<Signal<void> *>(signalIter->second);
			SE_CORE_ASSERT(dyncastSignal);
			(*dyncastSignal)();
		}
	}

	void Clear();

private:
	typedef Map<BasicSignal::TypeID, BasicSignal *> SignalMap;
	std::unique_ptr<SignalMap> m_Signals;
};


}
